import re
import pickle


class MeSHTrie():
    """
    MeSHTrie convert the ASCII MeSH Terms into:
    * a trie with words of MeSH terms pointing to a list of MeSH numbers
    * a dictionary of mesh number pointing to mesh terms
    """
    def __init__(self, mesh_trie_file_name=None, mesh_dict_file_name=None):
        """
        construct an MeSHTrie object. If both mesh_trie_file_name and mesh_dict_file_name are provided, they will be loaded into this object.
        if either of them are not provided, the mesh_trie and
        :param mesh_trie_file_name: name of a pickle file store the mesh_trie generated by save_mesh_tries_to_pickle
        :param mesh_dict_file_name: name of a pickle file store the mesh_dict generated by save_mesh_tries_to_pickle
        """
        if mesh_trie_file_name and mesh_dict_file_name:
            self.mesh_tries = pickle.load(open(mesh_trie_file_name, 'rb'))
            self.mesh_dict = pickle.load(open(mesh_dict_file_name, 'rb'))
        else:
            self.mesh_tries = {}  # store mesh tries: token->token->...->list of mesh numbers
            self.mesh_dict = {}  # store mesh number -> mesh term dictionary

    def __read_record(self, file):
        """
        read one record and return a dictionary contains mesh term (mh), entry (en), and mesh number (mn)
        :return: the record dictionary, or None if no records are read
        """
        term = ""
        entries = set()
        numbers = set()
        line = file.readline()
        while line:
            mesh_term_re = re.match(r'^MH = (.+)$', line)
            if mesh_term_re:
                term = mesh_term_re.group(1)

            mesh_entry_re = re.match(r'^ENTRY = ([^|]+)(.*)$', line)
            if mesh_entry_re:
                entry = mesh_entry_re.group(1)
                entries.add(entry)

            mesh_entry_re = re.match(r'^PRINT ENTRY = ([^|]+)(.*)$', line)
            if mesh_entry_re:
                entry = mesh_entry_re.group(1)
                entries.add(entry)

            mesh_number_re = re.match(r'^MN = (.+)$', line)
            if mesh_number_re:
                number = mesh_number_re.group(1).strip()
                numbers.add(number)

            mesh_new_record = re.match(r'^\*NEWRECORD$', line)
            if mesh_new_record and term:
                result = {'term': term, 'entries': entries, 'numbers': numbers}
                # print(result)
                for number in numbers:
                    if "C04" in number:
                        self.mesh_dict[number] = term
                return result
            line = file.readline()
        return None

    @staticmethod
    def split_string_to_tokens(string, splitter=r'[\s,\-\n]'):
        """
        split string to tokens (words).
        :param string: the string to split
        :param splitter: splitter is an regular expression of characters should be used.
        :return: a list of tokens from the string.
        """
        tokens = re.split(splitter, string)
        result = [r.strip().lower() for r in tokens if r]  # get rid of empty string
        return result

    def build_mesh_trie(self, file_name):
        """
        build the mesh_trie from the MeSH ASCII file
        :param file_name: the MeSH file_name
        :return: no return
        """
        with open(file_name, 'r') as fp:
            while True:
                record = self.__read_record(fp)
                if record is None:
                    break

                num_norm_set = set()
                for num in record['numbers']:
                    if "C04" in num:
                        num_norm_set.add(num)
                if len(num_norm_set) > 0:
                    term_tokens = []
                    term_tokens.append(self.split_string_to_tokens(record['term']))
                    for entry in record['entries']:
                        term_tokens.append(self.split_string_to_tokens(entry))

                    for tokens in term_tokens:
                        self.__add_to_mesh_tries(tokens, num_norm_set)


    def __add_to_mesh_tries(self, tokens, mesh_numbers):
        current = self.mesh_tries
        for token in tokens:
            if not (token in current):
                current[token] = {}
            current = current[token]
        if current != self.mesh_tries:
            if not ('mesh_numbers' in current):
                current['mesh_numbers'] = set()
            current['mesh_numbers'].update(mesh_numbers)

    def tokens_to_mesh_terms(self, tokens):
        """
        take a list of tokens and returns the mesh number associated with it
        :param tokens: a list of tokens, order matters
        :return: a dictionary of the term and mesh number associated with it
        """
        result = {}

        total = len(tokens)
        i = 0
        while i < total:
            current = self.mesh_tries
            start = i
            while i < total and tokens[i] in current:
                current = current[tokens[i]]
                i = i + 1
            end = i
            if 'mesh_numbers' in current:
                term = ' '.join(tokens[start:end])
                result[term] = []
                result[term].extend(current['mesh_numbers'])
            else:
                i = start + 1

        return result

    def string_to_mesh_dictionary(self, string):
        """
        take a string and find the mesh term-> mesh numbers
        :param string: return the mesh term-> mesh numbers dictionary
        :return:
        """
        tokens = self.split_string_to_tokens(string)
        return self.tokens_to_mesh_terms(tokens)

    def save_mesh_tries_to_pickle(self, mesh_trie_file_name, mesh_dict_file_name):
        """
        save mesh tires to pickle
        and mesh_dict to pickle
        :param mesh_trie_file_name: file name for the pickle file
        :return: None
        """

        pickle.dump(self.mesh_tries, open(mesh_trie_file_name, 'wb'))
        pickle.dump(self.mesh_dict, open(mesh_dict_file_name, 'wb'))

    @staticmethod
    def up_level_mesh_numbers(mesh_numbers, level=3):
        """
        return a list of mesh numbers that have been down leveled to the given level.
        since the numbers have been down leveled, there may be repeat values.
        :param mesh_numbers: the mesh_number list for set
        :param level: the level need to be down leveled to
        :return: the list of down leveled mesh numbers
        """
        result = []
        for number in mesh_numbers:
            matched=MeSHTrie.up_level_mesh_number(number, level)
            if matched:
                result.append(matched)
        return result

    @staticmethod
    def up_level_mesh_number(number, level=3):
        """
        return a mesh number that have been down leveled to the given level.
        :param mesh_number: the mesh_number
        :param level: the level need to be down leveled to
        :return: the down leveled mesh number
        """
        reg = r'([a-zA-Z]\d\d)(\.\d{{3}}){{0,{}}}'.format(level - 1)
        pattern = re.compile(reg)
        matched = pattern.search(number)
        if matched:
            result=matched.group(0)
        else:
            result=None
        return result

    def mesh_number2term(self, mesh_number):
        """
        convert mesh_number to mesh term
        :param mesh_number: the mesh_number to look up
        :return: the corresponding mesh_term or None if the mesh_number is not found in the dictionary
        """
        if mesh_number in self.mesh_dict:
            return self.mesh_dict[mesh_number]
        else:
            return None

    def mesh_numbers2terms(self, mesh_numbers):
        """
        convert mesh_numbers to corresponding mesh terms
        :param mesh_numbers: mesh_numbers to look up
        :return: a list of mesh terms or an empty list if no terms are found
        """
        result=[]
        for number in mesh_numbers:
            term=self.mesh_number2term(number)
            if term:
                result.append(term)
        return result


def mesh_to_mesh_trie():
    print(r'-- build mesh tries and save to pickle --')
    mt = MeSHTrie()
    print(r'building mesh tries...')
    mt.build_mesh_trie(r'd2017.bin')
    print(r'saving mesh_trie.pickle and mesh_dict.pickle')
    mt.save_mesh_tries_to_pickle(r'pickles/C04_trie.pickle', r'pickles/C04_dict.pickle')
    print(r'done')


if __name__ == '__main__':
    mesh_to_mesh_trie()